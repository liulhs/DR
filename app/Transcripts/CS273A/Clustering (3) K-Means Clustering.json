[
    {
        "timestamp": "00:00:00",
        "text": "Another very popular method for clustering is the k-means algorithm, which we describe next."
    },
    {
        "timestamp": "00:00:06",
        "text": "k-means is a simple procedure for finding clusters, which iterates between assigning the data points to clusters and updating the cluster's summarization based on the assigned data."
    },
    {
        "timestamp": "00:00:13",
        "text": "In MATLAB, this is available as the k-means function in the Statistics Toolbox."
    },
    {
        "timestamp": "00:00:20",
        "text": "For our notation, we'll denote data example i as x sub i."
    },
    {
        "timestamp": "00:00:26",
        "text": "Notice I use a subscript here instead of our usual superscript."
    },
    {
        "timestamp": "00:00:33",
        "text": "And we'll assume that there are exactly k clusters."
    },
    {
        "timestamp": "00:00:40",
        "text": "Each cluster is described by a single center point, mu c."
    },
    {
        "timestamp": "00:00:46",
        "text": "So here we have three clusters, mu1, mu2, and mu3."
    },
    {
        "timestamp": "00:00:53",
        "text": "And each cluster claims a set of nearby points, here, so that the cluster is effectively defined by closeness to the cluster center."
    },
    {
        "timestamp": "00:00:59",
        "text": "We'll also need to think about the assignment of particular data points to clusters."
    },
    {
        "timestamp": "00:01:05",
        "text": "So we'll do this with a variable called z, indexed by i, running over the data points."
    },
    {
        "timestamp": "00:01:10",
        "text": "So there's one assignment zi for each data point i."
    },
    {
        "timestamp": "00:01:15",
        "text": "And z takes on values 1 through k."
    },
    {
        "timestamp": "00:01:20",
        "text": "So z indicates which cluster the point is assigned to."
    },
    {
        "timestamp": "00:01:25",
        "text": "So if this is point 1, then z1 tells us that this point has been assigned to cluster 1."
    },
    {
        "timestamp": "00:01:30",
        "text": "If this is point 2, then z2 equals 3 tells us that that point is assigned to cluster 3, and so on."
    },
    {
        "timestamp": "00:01:35",
        "text": "Now, to run k-means, we start by initializing the cluster center's mu to some locations."
    },
    {
        "timestamp": "00:01:40",
        "text": "We'll discuss the initialization in more detail later."
    },
    {
        "timestamp": "00:01:45",
        "text": "k-means then proceeds by iterating over two steps."
    },
    {
        "timestamp": "00:01:50",
        "text": "First, for each data point, we'll find the closest cluster center."
    },
    {
        "timestamp": "00:01:55",
        "text": "So zi takes on the value c that minimizes the distance between point xi and the cluster center."
    },
    {
        "timestamp": "00:02:00",
        "text": "center, mu C."
    },
    {
        "timestamp": "00:02:06",
        "text": "So in this plot, for each data point, we're going to decide which of these two cluster centers to assign each data point to."
    },
    {
        "timestamp": "00:02:13",
        "text": "We can visualize that with arrows."
    },
    {
        "timestamp": "00:02:20",
        "text": "So for instance, this data point's assignment is to cluster 1, this one also, while this data point's assignment is to cluster 2."
    },
    {
        "timestamp": "00:02:26",
        "text": "Then we update the cluster center's mu sub C by setting mu C to the centroid, or mean, of the data that are assigned to cluster C."
    },
    {
        "timestamp": "00:02:33",
        "text": "So SC is the set of all data points that have ZI equal to C, MC is their total number, and then mu C is simply the average of those assigned data points."
    },
    {
        "timestamp": "00:02:39",
        "text": "Over here in B, we show that process."
    },
    {
        "timestamp": "00:02:46",
        "text": "Once these points have been assigned to cluster 1, then cluster 1 is updated to be the centroid of those two points."
    },
    {
        "timestamp": "00:02:53",
        "text": "These points are assigned to cluster 2, and mu 2 is moved to be"
    },
    {
        "timestamp": "00:02:59",
        "text": "centroid of those three points."
    },
    {
        "timestamp": "00:03:07",
        "text": "We can now go back and repeat step A, finding the minimizing cluster center, the closest clusters to each data point, and then repeat step B, moving the means to be the mean of the assigned points, and so on."
    },
    {
        "timestamp": "00:03:14",
        "text": "This procedure can be viewed as optimizing a cost function over the data, assignments, and cluster centers, which measures how much error is introduced by summarizing data point I with its cluster center that it's assigned to."
    },
    {
        "timestamp": "00:03:22",
        "text": "So mu sub zI is the cluster center that's assigned via index zI."
    },
    {
        "timestamp": "00:03:29",
        "text": "We measure this just with Euclidean distance."
    },
    {
        "timestamp": "00:03:37",
        "text": "Then the algorithm is simply a coordinate descent procedure."
    },
    {
        "timestamp": "00:03:44",
        "text": "Step A is minimizing cost function over the assignments z."
    },
    {
        "timestamp": "00:03:52",
        "text": "If we fix the cluster center's mu sub c,"
    },
    {
        "timestamp": "00:03:59",
        "text": "You can see that only one term in the sum depends on each zi, the term corresponding to data point i."
    },
    {
        "timestamp": "00:04:08",
        "text": "So if we minimize over zi, we can just check the distances from that point to each of the two clusters and choose the one that's smallest."
    },
    {
        "timestamp": "00:04:17",
        "text": "Step b, then minimizes the function over the locations mu."
    },
    {
        "timestamp": "00:04:25",
        "text": "If we fix the zis, then the terms that depend on any particular mu, say mu1, are only those terms that have the data assigned to cluster 1, so zi equal to 1."
    },
    {
        "timestamp": "00:04:34",
        "text": "Then it's easy to show that the location of mu that minimizes the sum of squared errors is simply the centroid or mean."
    },
    {
        "timestamp": "00:04:42",
        "text": "Then, since each step, a and b, is minimizing over some variables given the others, each step is guaranteed to decrease the cost at every step."
    },
    {
        "timestamp": "00:04:51",
        "text": "Since the cost is decreasing and bounded below, that means it must converge."
    },
    {
        "timestamp": "00:04:59",
        "text": "At some point, the updated means will lead us to the same assignments, which lead us to the same means, and so on."
    },
    {
        "timestamp": "00:05:09",
        "text": "Although this procedure is guaranteed to converge, it's not guaranteed to find a global optimum of the cost function."
    },
    {
        "timestamp": "00:05:19",
        "text": "In fact, the resulting clustering often depends quite a lot on the algorithm's initialization."
    },
    {
        "timestamp": "00:05:29",
        "text": "So in practice, we often work by starting with several randomly chosen initializations and then running the algorithm from each, we get several different clusterings."
    },
    {
        "timestamp": "00:05:39",
        "text": "Then we can use the cost C of each clustering to select among our results, and this gives us a better approximation to the global optimum."
    },
    {
        "timestamp": "00:05:49",
        "text": "So for example, after one initialization and run, we might end up with this clustering here with cost 223.3. If we initialize differently and then run again, we might find a better clustering here, so slightly lower cost."
    },
    {
        "timestamp": "00:05:59",
        "text": "212.6. And after we've run a few more with different random initializations, we might find yet a better clustering here, meaning a lower cost."
    },
    {
        "timestamp": "00:06:08",
        "text": "This has cost 167.0. So after several such executions, we can then keep the best according to this cost function C."
    },
    {
        "timestamp": "00:06:17",
        "text": "Given the importance of initialization to the results, there's been a fair amount of thought into how to initialize k-means."
    },
    {
        "timestamp": "00:06:25",
        "text": "The simplest way is to initialize randomly."
    },
    {
        "timestamp": "00:06:34",
        "text": "Usually that's done by choosing k of the data points themselves at random to be the initial cluster centers."
    },
    {
        "timestamp": "00:06:42",
        "text": "This ensures that the cluster centers will at least be near some data, since they're actual data points, and large groups of data will probably end up getting one."
    },
    {
        "timestamp": "00:06:51",
        "text": "But the drawback is that it may choose two points that are near each other or within the same group of data, such as has happened over here."
    },
    {
        "timestamp": "00:06:59",
        "text": "To avoid cluster centers that are too close to each other, one option is to choose faraway points."
    },
    {
        "timestamp": "00:07:06",
        "text": "So we could start by one randomly chosen data point, say here, to be our first cluster center."
    },
    {
        "timestamp": "00:07:13",
        "text": "Then, we find the data point that's farthest from that data point as the next cluster center, here."
    },
    {
        "timestamp": "00:07:19",
        "text": "At each step, we score all the data by their distance to the closest of the already selected points."
    },
    {
        "timestamp": "00:07:26",
        "text": "Then, we choose as our next cluster center the data point that's furthest away."
    },
    {
        "timestamp": "00:07:33",
        "text": "While this solves the issue of choosing too nearby data, it's also imperfect, as it will often choose outlier data points, so data that are very far away from all the other data."
    },
    {
        "timestamp": "00:07:39",
        "text": "These data tend to be unusual in the data set and not very good centers."
    },
    {
        "timestamp": "00:07:46",
        "text": "Also, the procedure is not very random."
    },
    {
        "timestamp": "00:07:53",
        "text": "So that means that if we run k-means multiple times, we'll often get very similar initializations."
    },
    {
        "timestamp": "00:07:59",
        "text": "lot of opportunity to improve on the quality of our overall clustering by starting with a better initialization."
    },
    {
        "timestamp": "00:08:08",
        "text": "A nice balance is the k-means plus plus algorithm which was proposed some years ago."
    },
    {
        "timestamp": "00:08:17",
        "text": "This technique chooses the next cluster location to be far but random from the already selected locations."
    },
    {
        "timestamp": "00:08:25",
        "text": "So like the distance method, we score each point by its distance to the already selected clusters."
    },
    {
        "timestamp": "00:08:34",
        "text": "But then instead of choosing the furthest point, we choose the next center randomly with probability proportional to the squared distance."
    },
    {
        "timestamp": "00:08:42",
        "text": "So this means that data that are far away here will have higher probability, but also areas of the space that have a lot of data will also tend to have higher probability since we might choose any of those points to be a cluster center."
    },
    {
        "timestamp": "00:08:51",
        "text": "So this procedure also has significantly more randomness than the max distance method, which helps us get diverse initializations across runs."
    },
    {
        "timestamp": "00:08:59",
        "text": "Once we have a clustering of our data, one common issue we might run into is that we'd like to describe new points that weren't available during the clustering using our cluster centers."
    },
    {
        "timestamp": "00:09:07",
        "text": "So these are called out-of-sample data, since they weren't in the data sample that was available during clustering."
    },
    {
        "timestamp": "00:09:14",
        "text": "This is actually quite easy for k-means."
    },
    {
        "timestamp": "00:09:22",
        "text": "We can just compute the cluster assignment of the new data point without updating that cluster's location."
    },
    {
        "timestamp": "00:09:29",
        "text": "So each cluster claims a part of the space that's nearer to that cluster center than any other."
    },
    {
        "timestamp": "00:09:37",
        "text": "So this results in a Voronoi tessellation, just like we saw in our nearest neighbor decision boundaries."
    },
    {
        "timestamp": "00:09:44",
        "text": "In fact, we can evaluate the out-of-sample assignment using something like our k-nearest neighbor code here."
    },
    {
        "timestamp": "00:09:52",
        "text": "After finding the means, mu, using our clustering, we can create a nearest neighbor classifier using those centers and the IDs of the clusters, and then compute the assignment by just predicting in that model."
    },
    {
        "timestamp": "00:09:59",
        "text": "Another critical choice we run into in k-means is the value of k, the number of clusters that we try to find."
    },
    {
        "timestamp": "00:10:08",
        "text": "So what happens if we try to choose the best value of k for this cost function here?"
    },
    {
        "timestamp": "00:10:17",
        "text": "Suppose we cluster these data with three clusters, and we do a lot of initializations and find the optimal clustering."
    },
    {
        "timestamp": "00:10:25",
        "text": "If we then compare to what happens when we cluster with five clusters, we'll find that we reduce the total cost."
    },
    {
        "timestamp": "00:10:34",
        "text": "So here, for example, two of the clusters, this red one has been split into two parts, and this green one has been split into two parts."
    },
    {
        "timestamp": "00:10:42",
        "text": "And so the data in these clusters must be closer to their cluster centers than the data in these ones."
    },
    {
        "timestamp": "00:10:51",
        "text": "If we increase k still further to say 10 clusters, this continues with the clusters growing ever smaller, and hence the cluster centers being ever closer to their associated..."
    },
    {
        "timestamp": "00:10:59",
        "text": "data points."
    },
    {
        "timestamp": "00:11:05",
        "text": "Thus, the cost function, C, always decreases with larger K."
    },
    {
        "timestamp": "00:11:10",
        "text": "So, if K equals M, the number of data points, the cost is actually zero."
    },
    {
        "timestamp": "00:11:16",
        "text": "Each data point will be its own cluster center."
    },
    {
        "timestamp": "00:11:21",
        "text": "We can see this as a model complexity issue."
    },
    {
        "timestamp": "00:11:27",
        "text": "Choosing K, like other model selection or hyperparameter choice problems, just can't be accomplished using the training data."
    },
    {
        "timestamp": "00:11:32",
        "text": "In fact, in this case, even testing error, using our out-of-sample procedure from a second ago, is not really meaningful, since the assignment of the test error is chosen to be the closest cluster center."
    },
    {
        "timestamp": "00:11:38",
        "text": "So, the more cluster centers there are, the closer the nearest one will be."
    },
    {
        "timestamp": "00:11:43",
        "text": "A typical solution is to penalize for model complexity."
    },
    {
        "timestamp": "00:11:49",
        "text": "So, our total cost is not only the squared error of the data, but plus a term that increases with the number of clusters."
    },
    {
        "timestamp": "00:11:54",
        "text": "So, the total error is the squared error plus a complexity term."
    },
    {
        "timestamp": "00:12:00",
        "text": "That way, adding more clusters can actually increase the cost if adding them doesn't decrease the squared error enough to compensate for the increased complexity."
    },
    {
        "timestamp": "00:12:05",
        "text": "So we visualize that here."
    },
    {
        "timestamp": "00:12:10",
        "text": "Red is the squared error, which gets better with k."
    },
    {
        "timestamp": "00:12:16",
        "text": "Green is the complexity term, which increases with k."
    },
    {
        "timestamp": "00:12:21",
        "text": "And blue is their sum, which gets better as k increases for a while."
    },
    {
        "timestamp": "00:12:27",
        "text": "But then, as the squared error becomes near zero, it starts to increase as the complexity keeps going up."
    },
    {
        "timestamp": "00:12:32",
        "text": "For example, a common choice for this complexity penalty is the Bayesian Information Criterion, or BIC, penalty."
    },
    {
        "timestamp": "00:12:38",
        "text": "So here's a simple version of that penalty."
    },
    {
        "timestamp": "00:12:43",
        "text": "BIC is used to penalize the likelihood of a probability model over data."
    },
    {
        "timestamp": "00:12:49",
        "text": "So to apply it here, we can interpret the cost function squared error as a likelihood of a multivariate Gaussian with a fixed variance and unknown mean."
    },
    {
        "timestamp": "00:12:54",
        "text": "So BIC actually balances the log."
    },
    {
        "timestamp": "00:13:00",
        "text": "of the squared error with a term that increases with k times log m over m."
    },
    {
        "timestamp": "00:13:10",
        "text": "So what we find is that the penalty here increases with the number of clusters k, but decreases with the number of data m, so that the more data we have, the more clusters we're able to pick."
    },
    {
        "timestamp": "00:13:20",
        "text": "So this penalty is a rather simple version of the probabilistic model plus BIC."
    },
    {
        "timestamp": "00:13:30",
        "text": "For a more precise and detailed version of this approach, along with tricks for computational efficiency and other things, you can see, for example, a paper called x-means from a KDD conference a few years back."
    },
    {
        "timestamp": "00:13:40",
        "text": "In summary, the k-means clustering approach describes each cluster using a single point in the data feature space called the cluster center."
    },
    {
        "timestamp": "00:13:50",
        "text": "After initializing these locations, we proceed by updating the assignment of each data point to its closest center."
    },
    {
        "timestamp": "00:14:00",
        "text": "Then, moving the cluster center to be as close as possible to all the assigned data."
    },
    {
        "timestamp": "00:14:08",
        "text": "This can be viewed as a coordinate descent procedure on a mean squared error criterion."
    },
    {
        "timestamp": "00:14:17",
        "text": "However, this optimization process is prone to local optima, so initialization can be very important."
    },
    {
        "timestamp": "00:14:25",
        "text": "By starting from several randomized initializations, we can improve our representation by selecting the final clustering that has lowest cost."
    },
    {
        "timestamp": "00:14:34",
        "text": "It's also easy to apply the cluster definitions to out-of-sample data by just applying the assignment procedure to new data points."
    },
    {
        "timestamp": "00:14:42",
        "text": "Choosing the number of clusters K can be very difficult and is a model selection problem, since increasing K always reduces the K-means cost function."
    },
    {
        "timestamp": "00:14:51",
        "text": "By adding a complexity penalty like BIC that increases with the number of clusters K, we can try to trade off a relative improvement in the mean squared error and weigh whether it was worth the increase in model complexity from increasing K."
    },
    {
        "timestamp": "00:15:00",
        "text": "you"
    }
]